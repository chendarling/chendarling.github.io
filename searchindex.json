[{"section":"Blog","slug":"/blog/post-agent_ai/","title":"Agent AI基础知识笔记","description":"this is meta description","date":"March 23, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_a0b5d177c561ea76.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"202\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_edb9469d6f833301.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_5a3cc60eb3ef125d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_13ed667b8d61b2a5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"AI","tags":"AI, Agent","content":""},{"section":"Blog","slug":"/blog/post-alg-graph/","title":"BUGAWAY算法小抄-几类图算法模板","description":"this is meta description","date":"March 20, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_a0b5d177c561ea76.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"202\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_edb9469d6f833301.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_5a3cc60eb3ef125d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_13ed667b8d61b2a5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法小抄","tags":"算法小抄, 图论, 算法板子, BFS, DFS, 并查集, 最小生成树","content":"几类图算法板子题🪜 如下总结了几类常见的图论算法板子题。是需要记住的！\n深度优先遍历DFS class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { int n = graph.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); // 因为是有向无环图，因此不需要存储状态表 dfs(graph,0,new ArrayList\u0026lt;Integer\u0026gt;(),res); return res; } public void dfs(int[][] graph, int curNode, List\u0026lt;Integer\u0026gt; path, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; paths){ path.add(curNode); if(curNode == graph.length - 1){ paths.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } int[] neNodes = graph[curNode]; for(int i = 0; i \u0026lt; neNodes.length; ++i){ dfs(graph,neNodes[i],path,paths); path.remove(path.size() - 1); // 撤销选择 } } } 广度优先遍历BFS class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { // 有向无环图，因此不需要额外存储状态 int n = graph.length; Queue\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); // offer(), poll() List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; init = new ArrayList\u0026lt;\u0026gt;(); init.add(0); q.offer(init); while(!q.isEmpty()){ List\u0026lt;Integer\u0026gt; li = q.poll(); int cur = li.get(li.size()-1); if(cur == n-1){ res.add(new ArrayList\u0026lt;\u0026gt;(li)); } int[] neighbors = graph[cur]; for(int i = 0; i \u0026lt; neighbors.length; ++i){ List\u0026lt;Integer\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(li); temp.add(neighbors[i]); q.offer(temp); } } return res; } } 并查集 class Solution { public int findCircleNum(int[][] isConnected) { // 假设每个城市都是一个省份，当城市间两两联通时，省份数量-- int n = isConnected.length; // 省份数量 UnionFind uf = new UnionFind(n); for(int i = 0; i \u0026lt; n-1; ++i){ for(int j = i+1; j \u0026lt; n; ++j){ if(isConnected[i][j] == 1){ uf.union(i,j); } } } return uf.province_cnt; } } class UnionFind { private int[] root; private int[] rank; public int province_cnt; public UnionFind(int n){ this.root = new int[n]; this.rank = new int[n]; this.province_cnt = n; for(int i = 0; i \u0026lt; n; ++i){ this.root[i] = i; this.rank[i] = 1; } } public int find(int x){ // 路径压缩 if(x == this.root[x]){ return x; } return this.root[x] = find(this.root[x]); } public void union(int x, int y){ // 按秩优化 int rootx = find(x); int rooty = find(y); if(rootx != rooty){ this.province_cnt--; if(this.rank[rootx] \u0026gt; this.rank[rooty]){ this.root[rooty] = rootx; }else if(this.rank[rootx] \u0026lt; this.rank[rooty]){ this.root[rootx] = rooty; }else{ this.root[rooty] = rootx; this.rank[rootx] += 1; } } } } 最小生成树 class Solution { public int minCostConnectPoints(int[][] points) { // Prim 算法 // 1. 设置两个顶点集合，一个是没访问过的顶点集合unvisited，一个是访问过的顶点集合 visited // 2. 从 unvisited 随机取出一个点加入 visited // 3. 从 visited 顶点集合中向外拓展的边中选择最小的加入 // 4. 重复步骤 2 和步骤 3 直到 unvisited为空 int n = points.length; int fee = 0; if(n == 0)return 0; PriorityQueue\u0026lt;Edge\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((x,y) -\u0026gt; x.dis - y.dis); // 最小堆 int[] visited = new int[n]; // 首先将第一个点先加进去 for (int j = 1; j \u0026lt; n; j++) { // Calculate the distance between two coordinates. int[] coordinate1 = points[0]; int[] coordinate2 = points[j]; int cost = Math.abs(coordinate1[0] - coordinate2[0]) + Math.abs(coordinate1[1] - coordinate2[1]); Edge edge = new Edge(0, j, cost); pq.add(edge); } visited[0] = 1; int cnt = n - 1; while(cnt \u0026gt; 0){ Edge edge = pq.poll(); int p1_idx = edge.left_point; int p2_idx = edge.right_point; int[] p2 = points[p2_idx]; if(visited[p2_idx] == 1)continue; cnt--; fee += edge.dis; visited[p2_idx] = 1; for(int i = 0; i \u0026lt; n; ++i){ if(visited[i] == 0){ int[] p3 = points[i]; int dis = Math.abs(p2[0]-p3[0]) + Math.abs(p2[1]-p3[1]); pq.add(new Edge(p2_idx, i, dis)); } } } return fee; } } class Edge { int left_point; int right_point; int dis; public Edge(int x, int y, int dis){ this.left_point = x; this.right_point = y; this.dis = dis; } } "},{"section":"Blog","slug":"/blog/post-alg-diff_arr/","title":"BUGAWAY算法小抄-差分数组","description":"this is meta description","date":"March 20, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_a0b5d177c561ea76.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"202\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_edb9469d6f833301.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_5a3cc60eb3ef125d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_13ed667b8d61b2a5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法小抄","tags":"算法小抄, 差分数组","content":"什么是差分数组？ 差分数组的思想是通过对原始数组进行处理，得到一个新的数组（差分数组），利用该数组来高效地进行区间更新操作。具体来说，差分数组记录的是相邻元素之间的差值，而不是原始数组的元素本身。\n差分数组的原理 1. 差分数组的构造： 假设有一个数组 A = [a1, a2, a3, ..., an]，我们可以构造一个差分数组 D，使得 D[i] = A[i] - A[i-1]（D[0] = A[0]）。\n这样，D 记录了 A 中相邻元素的差值。\n2. 区间更新： 在差分数组中，给定一个区间 [l, r]，想要将该区间内的所有元素加上某个值 v，只需要做以下两步操作：\nD[l] += v，表示从位置 l 开始所有元素都增加 v。 D[r+1] -= v，表示从位置 r+1 开始所有元素都不再增加 v。 最后，通过差分数组计算得到原始数组的最终值。\n3. 恢复原始数组： 利用差分数组 D 可以恢复原始数组 A，通过累加差分数组的元素得到原数组的值：\nA[0] = D[0] A[i] = D[i] + D[i-1] + ... + D[0] （即累加差分数组的值） 差分数组的算法应用 差分数组主要用于高效地处理区间更新操作，通常出现在以下几类问题中：\n1. 区间加法操作： 如果需要对数组的一个区间 [l, r] 进行加法更新，传统的方法可能需要遍历区间内的每个元素，时间复杂度是 O(r - l + 1)，但通过差分数组可以将区间更新的时间复杂度降为 O(1)。这使得对于大量的区间更新操作，算法效率大大提高。\n示例：\n给定一个数组 arr 和多个区间 [l, r, v]，对于每个区间，将 arr[l] 到 arr[r] 之间的所有元素加上 v。使用差分数组处理，可以将时间复杂度从 O(k * n)（k 个区间，n 为数组大小）降低到 O(k + n)。 2. 区间查询问题： 如果题目需要在处理区间更新的同时进行区间查询，差分数组也可以与前缀和结合，帮助实现高效的查询和更新。\n差分数组用于快速实现区间加法更新。\n前缀和则用于在差分数组上进行恢复，快速查询指定区间的和。\n示例：\n对数组进行区间更新后，要求查询某个位置的元素值。差分数组通过前缀和可以在 O(1) 时间内恢复出数组元素。 3. 区间求和与区间赋值操作： 在一些变种问题中，差分数组的思想可以用来进行区间求和或其他区间相关的操作，减少时间复杂度。\n🥱闲话少说，直接上例题！\n实践 731. 我的日程安排表 II class MyCalendarTwo { // 由于时间范围比较大，可以考虑用TreeMap实现 TreeMap\u0026lt;Integer, Integer\u0026gt; cnt; public MyCalendarTwo() { cnt = new TreeMap\u0026lt;Integer, Integer\u0026gt;(); } public boolean book(int start, int end) { // 预定[start,end]的时段，说明该时段每个时点的预定数都需要+1——符合差分数组“区间更新”的思想。 int ans = 0; int maxBook = 0; cnt.put(start, cnt.getOrDefault(start, 0) + 1); cnt.put(end, cnt.getOrDefault(end, 0) - 1); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : cnt.entrySet()) { int freq = entry.getValue(); maxBook += freq; ans = Math.max(ans, maxBook); if (maxBook \u0026gt; 2) { // 复原操作 cnt.put(start, cnt.getOrDefault(start, 0) - 1); cnt.put(end, cnt.getOrDefault(end, 0) + 1); return false; } } return true; } } /** * Your MyCalendarTwo object will be instantiated and called as such: * MyCalendarTwo obj = new MyCalendarTwo(); * boolean param_1 = obj.book(startTime,endTime); */ 732. 我的日程安排表 III class MyCalendarThree { TreeMap\u0026lt;Integer, Integer\u0026gt; cnt; public MyCalendarThree() { cnt = new TreeMap\u0026lt;Integer, Integer\u0026gt;(); } public int book(int start, int end) { int maxBook = 0; int ans = 1; cnt.put(start, cnt.getOrDefault(start, 0) + 1); cnt.put(end, cnt.getOrDefault(end, 0) - 1); for(Map.Entry\u0026lt;Integer, Integer\u0026gt; entry: cnt.entrySet()){ int freq = entry.getValue(); maxBook += freq; ans = Math.max(ans, maxBook); } return ans; } } /** * Your MyCalendarThree object will be instantiated and called as such: * MyCalendarThree obj = new MyCalendarThree(); * int param_1 = obj.book(startTime,endTime); */ "},{"section":"Blog","slug":"/blog/post-dp-1/","title":"BUGAWAY算法小抄-时间开销为O(k^n)的一类动态规划问题","description":"this is meta description","date":"March 20, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_a0b5d177c561ea76.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"202\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_edb9469d6f833301.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_5a3cc60eb3ef125d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_13ed667b8d61b2a5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法小抄","tags":"算法小抄, 动态规划","content":"131. 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串。返回 s 所有可能的分割方案。\n示例 1：\n输入：s = \u0026#34;aab\u0026#34;\r输出：[[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] 示例 2：\n输入：s = \u0026#34;a\u0026#34;\r输出：[[\u0026#34;a\u0026#34;]] 提示：\n1 \u0026lt;= s.length \u0026lt;= 16 s 仅由小写英文字母组成 ✏️ 题解\nclass Solution { private List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { // k^n的动态规划问题 // 回溯 + 动态规划预处理 // 动态规划预处理的是回文串(动规预处理这里有点难，要思考一下) // dp[i][j]表示字符串 s[i...j]是否是回文 // dp[i][j] = true when i \u0026gt;= j // dp[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; dp[i+1][j-1] int n = s.length(); boolean[][] dp = new boolean[n][n]; // 初始化 for (int i = 0; i \u0026lt; n; i++) { Arrays.fill(dp[i], true); } for (int i = n - 1; i \u0026gt;= 0; --i) { for (int j = i + 1; j \u0026lt; n; ++j) { dp[i][j] = (s.charAt(i) == s.charAt(j)) \u0026amp;\u0026amp; dp[i + 1][j - 1]; } } dfs(s, 0, new ArrayList\u0026lt;String\u0026gt;(), dp); return res; } // public boolean isPalindrome(String s) { // // 双指针常见做法判断字符串是否是回文串 // // 在该题的缺点是容易重复判断 // // if (s.length() == 0 || s.length() == 1) // // return true; // // int i = 0, j = s.length() - 1; // // while (i \u0026lt; j) { // // if (s.charAt(i) != s.charAt(j)) // // return false; // // i++; // // j--; // // } // // return true; // } public void dfs(String s, int i, List\u0026lt;String\u0026gt; ans, boolean[][] dp) { int n = s.length(); if (i == n) { res.add(new ArrayList\u0026lt;String\u0026gt;(ans)); return; } else { for (int j = i; j \u0026lt; n; j++) { if (dp[i][j]) { ans.add(s.substring(i, j + 1)); dfs(s, j + 1, ans, dp); ans.remove(ans.size() - 1); } } } } } 787. K 站中转内最便宜的航班 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。\n现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。\n示例 1：\n输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\rsrc = 0, dst = 2, k = 1\r输出: 200\r解释: 城市航班图如下\r从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2：\n输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\rsrc = 0, dst = 2, k = 0\r输出: 500\r解释: 城市航班图如下\r从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示：\n1 \u0026lt;= n \u0026lt;= 100 0 \u0026lt;= flights.length \u0026lt;= (n * (n - 1) / 2) flights[i].length == 3 0 \u0026lt;= fromi, toi \u0026lt; n fromi != toi 1 \u0026lt;= pricei \u0026lt;= 104 航班没有重复，且不存在自环 0 \u0026lt;= src, dst, k \u0026lt; n src != dst 🐧 腾讯 2024 技术岗春招笔试第四题 小红拿到了一个数组，她准备将数组分割成 k 段，使得每段内部做按位异或后，再全部求和。小红希望最终这个和尽可能大，你能帮帮她吗？\n示例 1：\n输入：arr = [1,1,1,2,3,4], k=2\r输出：10\r说明：分割方式：[1,1,1,2 | 3,4] 这道题和上面的有异曲同工之妙。（因为是笔试真题，没找到所有原题样例，只记得一个样例）\nimport java.util.Scanner; public class Demo84 { // 动态规划 f[i][cnt] 表示[i, n-1]分割 k-cnt 段能产生的最大和 return f[0][0] // 初始化最后一排为0，最后一列为0 内外层都是从后往前遍历 public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int k = in.nextInt(); int[] arr = new int[n]; int[] sum = new int[n + 1]; // 异或前缀和 for (int i = 0; i \u0026lt; n; i++) { arr[i] = in.nextInt(); sum[i + 1] = sum[i] ^ arr[i]; } long[][] f = new long[n + 1][k + 1]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= i; j++) { for (int s = 1; s \u0026lt;= k; s++) { f[i][s] = max(f[i][s], f[j][s - 1] + (sum[i + 1] ^ sum[j + 1])); } } } System.out.println(f[0][0]); } } "},{"section":"Blog","slug":"/blog/post-alg-tree_arr/","title":"BUGAWAY算法小抄-树状数组","description":"this is meta description","date":"March 18, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_a0b5d177c561ea76.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"202\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_edb9469d6f833301.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/alg_logo_hu_5a3cc60eb3ef125d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/alg_logo_hu_13ed667b8d61b2a5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法小抄","tags":"算法小抄, 树状数组","content":"什么是树状数组？ 树状数组是支持单点修改和区间查询的、代码量小的数据结构。\n事实上，树状数组能解决的问题是线段树（一棵二叉树，每个节点表示一个区间，并存储该区间的一些相关信息。线段树可以高效地进行区间查询和区间更新操作。不是本文重点）能解决的问题的子集：树状数组能做的，线段树一定能做；线段树能做的，树状数组不一定可以。然而，树状数组的代码要远比线段树短，时间效率常数也更小，因此仍有学习价值。\n有时，在差分数组和辅助数组的帮助下，树状数组还可解决更强的区间加单点值和区间加区间和问题。\n举个栗子🌰，想知道a[1,\u0026hellip;,7]的前缀和，怎么做？\n一种方法就是将所有数都加起来。但如果已知三个数 A，B，C，A=a[1,\u0026hellip;,4]，B=a[5,\u0026hellip;,6]，C=a[7,\u0026hellip;,7]。求和只需要 A + B + C 。\n这就是树状数组能快速求解信息的原因：我们总能将一段前缀拆成 不多于logn 段区间，使得这 logn 段区间的信息是 已知的。于是，我们只要合并这些段区间的信息，就可以得到答案，相比于原先直接合并 n 个元素，效率有了很大提升。\n直接上结论，不难发现，c[x]管辖的一定是==[x - lowbit(x)+1, x]==的区间总信息。如c[88]管辖的是[88-8+1,\u0026hellip;,88]即[81,\u0026hellip;,88]的区域（$88_{(10)}$=$1011000_{(2)}$，因此 lowbit(88) = $1000_{(2)}$=8）。\n⚠️注意：lowbit 指的不是x 的最低位1 所在的位数 k，而是这个 1 和其后面的 0 所组成的 $2^k$。\nlowbit 对应代码为：\npublic int lowbit(int x){ // x 的二进制中，最低位的 1 以及后面所有 0 组成的数。 // lowbit(0b01011000) == 0b00001000 // ~~~~^~~~ // lowbit(0b01110010) == 0b00000010 // ~~~~~~^~ return x \u0026amp; -x; } 树状数组有两大核心功能：\n单点更新 update(i, v)： 把序列 i 位置的数加上一个值 v； 区间查询 query(i)： 查询序列 [1⋯i] 区间的区间和，即 i 位置的前缀和； 修改和查询的时间代价都是 O(logn)，其中 n 为需要维护前缀和的序列的长度。\nOK，我们不扯长篇大论，以练促学，接下来我们实操一下！💪\n实践 【板子题】307. 区域和检索 - 数组可修改 class NumArray { private int[] nums; // 基础数组 private int[] tree; // 树状数组，功能是单点修改和区间查询。下标表示右边界。 public void add(int index, int val) { // 单点修改，把序列第 index 个数增加 val // 为保证效率，我们只需遍历并修改管辖了 a[index]的 tree[y]，其他的 tree 没有明显变化 // 管辖 a[index]的 tree[y] 一定包含tree[index]。所以 y 在形态上是 index 的祖先 // 因此我们从 index 开始不断往上跳父亲，直到超出数组边界 while (index \u0026lt; tree.length) { tree[index] += val; index += lowbit(index); } } public int prefixSum(int index) { // 区间查询，查询前 index 个元素的前缀和 int sum = 0; while (index \u0026gt; 0) { sum += tree[index]; index -= lowbit(index); } return sum; } public NumArray(int[] nums) { this.tree = new int[nums.length + 1]; this.nums = nums; for (int i = 0; i \u0026lt; nums.length; i++) { add(i + 1, nums[i]); } } public void update(int index, int val) { add(index + 1, val - nums[index]); nums[index] = val; } public int sumRange(int left, int right) { return prefixSum(right + 1) - prefixSum(left); } // lowbit 函数计算区间管辖的左边界 public int lowbit(int x) { return x \u0026amp; -x; } } 【离散化树状数组】315. 计算右侧小于当前元素的个数 class Solution { int[] a; // 原始数组 int[] c; // 树状数组 public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { // 离散化+ 树状数组 // 离散化的目的是因为“把原序列的值域映射到一个连续的整数区间，并保证它们的偏序关系不变。“ List\u0026lt;Integer\u0026gt; resultList = new ArrayList\u0026lt;\u0026gt;(); discretization(nums); init(nums.length); for(int i = nums.length -1; i \u0026gt;= 0; i--){ int id = getId(nums[i]); // 离散化之后相当于id 为 nums[i]在 nums 中第 id 小的元素 resultList.add(query(id-1)); // id-1是因为不包括 id 的个数 update(id); } Collections.reverse(resultList); return resultList; } public void init(int length){ c = new int[length]; Arrays.fill(c,0); } public int lowbit(int x){ return x \u0026amp; -x; } public int query(int pos){ // 范围查询 int ret = 0; while(pos \u0026gt; 0){ ret += c[pos]; pos -= lowbit(pos); } return ret; } public void update(int pos) { // 单点更新 while( pos \u0026lt; c.length){ c[pos] += 1; pos += lowbit(pos); } } // 离散化操作 public void discretization(int[] nums){ Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;Integer\u0026gt;(); for(int num: nums){ set.add(num); } int size = set.size(); // 有 size 个不一样的数 a = new int[size]; int index = 0; for(int num: set){ a[index++] = num; } Arrays.sort(a); } public int getId(int x){ return Arrays.binarySearch(a,x) + 1; } } 解释：\n过程如下：\n【离散化树状数组】493. 翻转对 "},{"section":"Blog","slug":"/blog/post-template/","title":"如何在该网站中撰写文章-模板🤔","description":"this is meta description","date":"March 18, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/post-template/shutterstock_hu_6f9034a2ae606b3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"280\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/post-template\\/shutterstock_hu_3069ac1a86865f9a.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blogs/post-template/shutterstock_hu_e56fa6b7688b46a7.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blogs\\/post-template\\/shutterstock_hu_31c2e04c64069ee3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"模板","tags":"模板","content":"正文内容 文章形式是基于MarkDown格式的，在blog目录下创建md格式文件即可，文件命名无要求。格式参照该文章源文件格式即可。\n参考：如何使用Hugo搭建博客并发布\nElements Here is an example of headings. You can use this heading by the following markdown rules. For example: use # for heading 1 and use ###### for heading 6.\nHeading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Emphasis The emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nThe combined emphasis with asterisks and underscores.\nStrike through uses two tildes. Scratch this.\nButton Button Link I\u0026rsquo;m an inline-style link\nI\u0026rsquo;m an inline-style link with title\nI\u0026rsquo;m a reference-style link\nI\u0026rsquo;m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself.\nURLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).\nSome text to show that the reference links can follow later.\nParagraph Lorem ipsum dolor sit amet consectetur adipisicing elit. Quam nihil enim maxime corporis cumque totam aliquid nam sint inventore optio modi neque laborum officiis necessitatibus, facilis placeat pariatur! Voluptatem, sed harum pariatur adipisci voluptates voluptatum cumque, porro sint minima similique magni perferendis fuga! Optio vel ipsum excepturi tempore reiciendis id quidem? Vel in, doloribus debitis nesciunt fugit sequi magnam accusantium modi neque quis, vitae velit, pariatur harum autem a! Velit impedit atque maiores animi possimus asperiores natus repellendus excepturi sint architecto eligendi non, omnis nihil. Facilis, doloremque illum. Fugit optio laborum minus debitis natus illo perspiciatis corporis voluptatum rerum laboriosam.\nOrdered List List item List item List item List item List item Unordered List List item List item List item List item List item Notice Note\nThis is a simple note.\nTip\nThis is a simple tip.\nInfo\nThis is a simple info.\nWarning\nThis is a simple warning.\nTab Tab 1 Tab 2 Tab 3 Hey There, I am a tab Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\nI wanna talk about the assassination attempt Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\nWe know you’re dealing in stolen ore Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo\nAccordions Why should you need to do this? Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur How can I adjust Horizontal centering Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur Should you use Negative margin? Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur Code and Syntax Highlighting This is an Inline code sample.\nvar s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s 1#include \u0026lt;stdio.h\u0026gt; 2 3int main(void) 4{ 5 printf(\u0026#34;hello, world\\n\u0026#34;); 6 return 0; 7} flowchart TD\rA[Start] --\u0026gt; B{Is it?}\rB -- Yes --\u0026gt; C[OK]\rC --\u0026gt; D[Rethink]\rD --\u0026gt; B\rB -- No ----\u0026gt; E[End] Blockquote Did you come here for something in particular or just general Riker-bashing? And blowing into maximum warp speed, you appeared for an instant to be in two places at once.\nTables Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 Image Gallery Slider Youtube video Custom video Your browser does not support the video tag. "}]